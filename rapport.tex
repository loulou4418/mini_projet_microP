\documentclass[a4paper]{article}
\usepackage[french]{babel}
\usepackage{geometry}
\geometry{a4paper}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\graphicspath{ {./data/} }
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{cite}
\usepackage{color}
\usepackage{float}
\usepackage{soul}


\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{CStyle}{
	backgroundcolor=\color{backgroundColour},   
	commentstyle=\color{mGreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{mGray},
	stringstyle=\color{mPurple},
	basicstyle=\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2,
	language=C
}          

\title{\textbf{projet} \\ document}

\author{Louison GOUY \and Yiying WEI}

\begin{document}

\maketitle

\vspace{2cm}

\begin{center}
   % \includegraphics[width=12cm]{logo_tp.jpg}
\end{center}

\vspace*{1cm}

\begin{center}
    name
\end{center}

\vspace*{7cm}

\begin{center}

abstract
\end{center}

\newpage
\vspace*{3cm}
\begin{quotation}
	"It's not you can use C to generate good code for hardware. If you think like a comupter writing C actually makes sens."
\end{quotation}
\begin{flushright}
	Linus Torvalds
\end{flushright} 
\newpage


\newpage
\renewcommand{\contentsname}{Table des Matières}
\tableofcontents
\newpage
\renewcommand\listfigurename{Liste des figures}
\listoffigures
\newpage

\section{Glossaire}

\textbf{Requête d'interruption} : (IRQ : interrupt request) Signal matériel indiquant qu'une interruption est requise. \\ ~ \\

\textbf{Polling} : approche d'ordonnancement dans laquelle le logiciel répète un test sur une condition pour déterminer s'il doit exécuter une tache.\cite{ARM_book} \\ ~ \\

Une\textbf{ machine état ou automate fini} est une construction mathématique abstraite, susceptible d'être dans un nombre fini d'\textit{états} , mais étant un moment donné dans un seul état à la fois. Le passage d'un état à un autre ce fait par une \textit{transition}. 

\newpage

\section{Le langage C}
Le langage C est un langage combiné, il a les caractéristiques des langages évolués (boucles itératives etc.) associé à des fonctionnalités des langages assemblés (décalage de bit, adressage indirect généralisé etc.). C'est la combinaison de ces deux caractéristiques qui font la force du langage\cite{Monteil2012}. Sa proximité avec l'assembleur le rendant très efficace, il est ainsi devenu le langage indispensable dans la programmation des applications comme l'automatique, la robotique, les OS ect. Cette même proximité impose peu de contraintes à l'utilisateur sur la structure de son programme. Aussi, il est possible d'écrire des fonctions avec plusieurs points de sorties, ou encore, d'échapper à une boucle avant son terme. Là où certains trouveront une grande souplesse, les critiques le considérerons trop permissif. On notera qu'un certain nombre d'organismes officiels proposent un ensemble de règles visant, tout en conservant son efficacité, à éviter les problèmes liés à une programmation peu soignée. L'Agence National de la Sécurité des Systèmes Informatiques française (ANSSI) propose un rapport complet, \textit{Règles de programmation pour le développement sécurisé de logiciels en langage C}\cite{ANSSI2021}, visant à "favoriser la production de logiciels C plus sécurisés, plus sûrs, d’une plus grande robustesse et portables". Il servira de référence durant ce projet.

\newpage

\section{Programme de base} % touver un meilleur titre

Dans un premier temps un nouveau projet est créé de type "GCC C ASF Board project". Microchip studio génère alors une arborescence de fichiers dont un main.c. Ce dernier est étudié de manière globale puis affinée par étape dans la section suivante.

\subsection{Vue globale}
Cette partie détaille le fonctionnement du programme de base. 


\begin{lstlisting}[style=CStyle]
#include <asf.h>

int main (void)
{
	system_init();
	
	/* Insert application code here, after the board has been initialized. */
	
	/* This skeleton code simply sets the LED to the state of the button. */
	while (1) {
		/* Is button pressed? */
		if (port_pin_get_input_level(BUTTON_0_PIN) == BUTTON_0_ACTIVE) {
			/* Yes, so turn LED on. */
			port_pin_set_output_level(LED_0_PIN, LED_0_ACTIVE);
		} else {
			/* No, so turn LED off. */
			port_pin_set_output_level(LED_0_PIN, !LED_0_ACTIVE);
		}
	\end{lstlisting}
	La première ligne permet d'inclure la  bibliothèque asf et ainsi de profiter du niveau d'abstraction mis à disposition par Microship. La suivante, \texttt{int main ()} bien connue des développeurs C, est le point d'entré du programme. C'est la première fonction exécutée. La ligne 5 \texttt{system\_init();} a été générée automatiquement par le logiciel à la création du projet. C'est elle qui nous offre ce niveau d'abstraction en initialisant les horloges et les entrées/sorties etc. Elle est spécifique à la cible utilisée, dans notre cas la carte Microchip SAMD21 Xplained Pro. La ligne 10 correspond à l'implémentation d'une boucle infinie. Cette dernière permet de lire l'état du bouton (ligne 12) en "continu". La condition suivante d’éclanche le résultat souhaité : allumage ou extinction de la LED0.
	
	\subsection{Affinage}
	
	\paragraph{Include ASF}
	~~\\
	L'Advanced Software Framework (ASF) fournit un riche ensemble de pilotes éprouvés et de modules de code développés par des experts pour réduire le temps de conception. Il simplifie l'utilisation des microcontrôleurs en fournissant une abstraction au matériel. ASF est une bibliothèque de code gratuite et open-source conçue pour être utilisée lors des phases d'évaluation, de prototypage, de conception et de production. Elle sera utilisée tout au long de ce TP et fera l'objet de nombreuses références.
	
	\paragraph{System\_init}
	~~\\
	Au début du \texttt{main} la fonction \texttt{system\_init()} est appelée. Comme son nom l'indique elle a pour but d'initialiser le système. Elle est définie dans le fichier \texttt{system.c} et consiste en un simple appel successif à cinq fonctions de configuration : 	 
	\texttt{system\_clock\_init();}
	\texttt{system\_board\_init();}
	\texttt{\_system\_events\_init();}
	\texttt{\_system\_extint\_init();}
	et  \texttt{\_system\_divas\_init();}.
	Elles jouent chacune un rôle essentiel dans l'initialisation de carte.
	
	\paragraph{Boucle infinie}
	~~\\
	Implémenté à travers un \texttt{tant que VRAI}, cette ligne n'est pas difficile à comprendre mais il peut être intéressant d'en établir le contexte. Le guide des bonnes de pratiques de l'ANSSI\cite{ANSSI2021} indique toutefois que la forme d'une boucle infinie est bien \texttt{while(1)} et non \texttt{for(;;)}\\
	De manière générale, le bouclage répète un jeu d'instruction jusqu'à se qu'une condition particulaire soit atteinte. On définit une boucle infinie dès lors que cette condition n'arrive jamais en raison d'une caractéristique inhérente à la boucle. Dans notre cas la condition de sortie serait VRAI=FAUX. C'est impossible ! \\
	Du point de vue matériel l'utilisation d'une boucle infinie permet de borner le programme compteur (PC) dans un espace mémoire bien définit. Le compilateur devrait l'interpréter par un jump ou jmp. Le mieux est probablement de le vérifier. Un fichier \texttt{loop.c} est créé, volontairement le plus simple possible.
	\begin{lstlisting}[style=CStyle]
		/* file loop.c */
		void main(void){while(1);}
	\end{lstlisting}
	Puis la commande \texttt{gcc -S -fverbose-asm loop.c} est exécutée dans un terminal linux. Un fichier \texttt{loop.s} apparaît. L'option \texttt{-S} indique la génération du code assembleur et \texttt{-fverbose-asm} ajoute des commentaires tel que la ligne C correspondant à l'instruction. On extrait du résultat la partie qui nous intéresse :
	\begin{lstlisting}[language={[x86masm]Assembler}]
		;file loop.s
		.L2:
		# loop.c:2: 	while (1);
		jmp	.L2	#
	\end{lstlisting}
	Le compilateur gcc a bien implémenté la boucle infinie via une instruction jump indiquant un saut du PC. Dans cette exemple, la boucle étant vide, le PC saute au même endroit. Il est intéressant de faire le parallèle avec l'assembleur. Cet exemple reste toutefois approximatif puisque ce n'est pas le jeux d'instruction du CORTEXM0+ qui a été utilisé. Prenons le comme une introduction.
	
	\paragraph{Condition sur E/S}
	~~\\
	Les lignes suivantes implémentées via une structure \texttt{if else} traduisent le comportement souhaité du point de vue utilisateur. A savoir, le maintient en position enfoncé du bouton provoque l'illumination de la LED0. La lecture de son état est permis grâce à la fonction \textbf{port\_pin\_get\_input\_level} retournant un entier de valeur \hl{XX} ou XX. Elle est alors comparé à \texttt{LED\_0\_ACTIVE} définit comme XX. Si la condition est vrai la fonction \texttt{port\_pin\_set\_output\_level} est appelé avec comme paramètre \texttt{LED\_0\_ACTIVE} sinon \texttt{!LED\_0\_ACTIVE}.
	
	
	\newpage
	\section{Programmation d'un timer}
	Cette étape vise à générer un signal carré de période 1ms sur une des sorties timer du microcontrôleur. Il s'agit donc de préparer l'implantation de la fonction Horloge. Cette fonction sera donc réalisée par une ressource matérielle du microcontrôleur ; un timer.
	\subsection{Fonctionnement d'un timer}
	Le microcontrôleur SAMD21 possède 5 timers/counters allant de TC3 à TC7. Il est possible de les paramétrer en fonction de l’utilisation qu’il en sera fait. Dans notre cas, le timer TC6 est imposé par le sujet du TP.\\
	Chaque timer peut prendre 3 configurations possibles : 8, 16 ou 32 bits\footnote{Le timer 32bits fonctionne en assemblant 2 timers 16 bits en cascade}. Le nombre de registres associés à chacune des configurations est différent. Nous utiliserons le mode 16 bits (65536 valeurs possibles).  \\
	\paragraph{Fonctionnement du TC en mode waveform}
	~~\\
	Les timers/counters (TC) du microcontrôleur SAMD21 proposent un mode de fonctionnement adapté à la production de signaux logiques : le mode {\sl waveform}. La sélection du mode se fait via la configuration de certains registres. L'objectif est de générer un signal rectangulaire de rapport cyclique quelconque. \\
	Il existe 4 modes de fonctionnement pour les compteurs en mode WAVEFORM présenté par la figure ci-dessous. \\
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{mode Waveform.jpg}
		\caption{Mode de fonctionnement en WAVEFORM pour les compteurs}
	\end{figure}
	
	Le mode Match Frequency Generation (MFRQ) est le plus adapté à l'application. En effet, la fréquence n'est fixée qu'avec un seul paramètre CC0. D'après la datasheet du SAMD21, le fonctionnement du mode MFRQ est le suivant. \\
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{Match Frequency Operation.jpg}
		\caption{Fonctionnement timer configuré en MFRQ}
	\end{figure}
	La période T du signal est contrôlée par le registre CC0. Le signal de sortie est numérique, sa valeur se trouve dans WO[0]. A chaque fois que le compteur COUNT atteint la valeur du registre CC0.  Le signal de sortie WO[0] est permuté. La valeur MAX correspond à la résolution du compteur : ici 16 bits donc 65536 valeurs possibles. Il faudra être vigilent car la valeur du compteur vaut deux fois celle du signal de sortie.\\
	
	\paragraph{Calculs pour une fréquence de 1kHz}
	~~\\
	Pour obtenir une fréquence de 1kHz il faut déterminer la valeur de CC0 comme expliqué précédemment. Pour faire cela il est primordial de bien comprendre son fonctionnement et les registres impliqués dans la configuration. La figure ci-dessous donne la fréquence de comptage. \\
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=12cm]{prescaler.jpg}
		\caption{Configuration du compteur TC}
	\end{figure}
	
	L'horloge count est fournie à partir de l’horloge GCLK\_TC (Generic clock for TC). Elle est l'horloge de référence pour les TC. Elle a une fréquence de 8MHz. Cette horloge peut être divisée en y appliquant un prescaler afin d’obtenir CLK\_TC\_CNT. N est une pré division de l’horloge du timer. Dans notre cas, le prescaler n’est pas appliqué et prendra la valeur N = 1. L'équation ci-dessous présente la fréquence à laquelle sera effectué le comptage. \\
	\begin{equation}
		T_{GCLK\_TC} = N*T_{CLK\_TC\_CNT} = T_{CLK\_TC\_CNT}
	\end{equation}
	
	Donc
	\begin{equation}
		f_{GCLK\_TC} = f_{CLK\_TC\_CNT}
	\end{equation}
	La fréquence souhaitée est établie à partir de l'équation suivante :
	\begin{equation}
		f_{WO[0]} = \frac{f_{CLK\_TC\_CNT}}{2*(CC0+1)}
	\end{equation}
	On sait que $f_{GCLK\_TC}$ est égale à 8 MHz. Pour une fréquence $f_{WO[0]}$ de 1kHz, on obtient\\
	\begin{equation}
		CC0 = \frac{f_{GCLK\_TC}}{2*f_{WO[0]}} - 1 = 3999
	\end{equation}
	La valeur chargée dans le registre CC0 sera donc 3999.
	
	\subsection{Configuration pour le TC6}
	Cette partie détaillé les configurations nécessaires à la génération d'un signal carré de 1kHz grâce à TC6. Les éléments suivants seront configuré : le generic clock controller, le power manager, un port d'entrée sortie et finalement TC6.
	\subsubsection{Configuration du Generic Clock(GCLK)} 
	Chaque périphérique de la carte SAMD21 nécessite une horloge de fonctionnement interne. Pour notre périphérique du Timer, il s’agit de GCLK\_TC6 (Generic clock for TC6).\\
	La figure ci-dessous présente la génération des signaux de l'horloge périphérique et de l'horloge principale. Le Generic Clock Controller est composé de 9 générateurs et de multiplexeurs.\\
	\begin{figure}[H]
		\centering
		\includegraphics[width=12cm]{GENCLK_bloc.jpg}
		\caption{Fonctionnement du Generic Clock Controller}
	\end{figure}
	On remarque que le Generic Clock Controller est divisé en deux parties. D’une part le Generic Clock Controler est configuré par le registre GENCTRL. D'autre part le Generic Clock Multiplexer est configuré par le registre CLKCTRL.\\
	
	\paragraph{Configuration du registre GENCTRL} 
	~~\\
	Le détail de Generic Clock Generator Control (GENCTRL) est donné dans la figure ci-dessous:\\
	\begin{figure}[H]
		\centering
		\includegraphics[width=12cm]{GENCTRL.jpg}
		\caption{Configuration des différents bits du GENCTRL}
	\end{figure}
	
	\begin{itemize}
		\item {\bf RUNSTDBY}: Fonctionnement en mode Standby ou non. Dans notre
		cas, nous voulons la désactiver donc il faut mettre {\bf 0\textless\textless21} dans ce champ.~~\\
		\item {\bf DIVSEL}: Définit le facteur de division de l’horloge. Nous ne voulons pas la diviser donc il faut mettre la valeur {\bf 0\textless\textless20} dans ce champ.~~\\
		\item {\bf OE}: Permet d’autoriser l’activation sur une sortie de GCLK. Nous ne voulons pas activer cette option donc il faut mettre la valeur {\bf 0\textless\textless19} dans ce champ.~~\\
		\item {\bf OOV}: Définit la valeur de la sortie de GCLK. Lorsque l’OE est à 0 il faut mettre également 0 dans ce champ donc la valeur {\bf 0\textless\textless18}.~~\\
		\item {\bf IDC}:Définit du rapport cyclique en cas de division impaire. Dans notre cas, il faut mettre la valeur {\bf 0\textless\textless17} dans ce champ.~~\\
		\item {\bf GENEN}: Validation ou non du générateur d’horloge. Nous voulons l’activer donc il faut mettre la valeur {\bf 1\textless\textless16} dans ce champ.~~\\
		\item {\bf SRC[4:0]}: Choix de la source d’horloge. Nous voulons choisir la source OSC8M donc d’après la datasheet il faut mettre la valeur {\bf 6\textless\textless8} dans ce champ. ~~\\
		\item {\bf ID[3:0]}: Définit le numéro du générateur que l'on configure (0 à 8). Nous choisissons la générateur 0 donc il faut mettre la valeur {\bf 0\textless\textless0}.
	\end{itemize}
	
	\paragraph{Configuration du registre CLKCTRL} 
	~~\\
	Ce registre permet de choisir parmis les 9 générateurs décrit précédemment. Le détail de Generic Clock Control (CLKCTRL) est donné dans la figure ci-dessous:\\
	\begin{figure}[H]
		\centering
		\includegraphics[width=12cm]{CLKCTRL.jpg}
		\caption{Configuration des différents bits du CLKCTRL}
	\end{figure}
	
	\begin{itemize}
		\item {\bf WRTLOCK}: Permet le verrouillage de l’horloge générique pour les générateurs 1 à 9. Nous avons choisi le générateur 0 et il n’y a pas de verrouillage donc il faut mettre {\bf 0\textless\textless15} dans ce champ.~~\\
		\item {\bf CLKEN}: Validation de l’horloge générique donc {\bf 1\textless\textless14} dans ce champ.~~\\
		\item {\bf GEN[3:0]}: Permet de choisir le générateur d’horloge d’entrée. Ici il s’agit GCLK\_GEN[0] donc il faut mettre {\bf 0\textless\textless8} dans ce champ.~~\\
		\item {\bf ID[5:0]}: Définit le périphérique vers lequel est dirigé l’horloge générique. Dans notre cas, il faut l’envoyer vers TC6 donc d’après la datasheet du SAMD21 il faut mettre la valeur {\bf 1D\textless\textless0}.~~\\
	\end{itemize}
	
	\subsubsection{Configuration du Power Manager(PM)} 
	Une horloge "bus" pour le timer TC6 est délivrée par le Power Manager (PM). Cette horloge permet du dialogue entre le Microprocesseur et le périphérique.\\
	Le Power Manager montré en figure ci-dessous gère une clock pour le CPU, une clock pour le bus AHB à destination de la mémoire et trois clocks pour le bus APB à destination des périphériques.\\
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.6\linewidth]{PM_bloc.jpg}
		\caption{Structure du Power Manager}
	\end{figure}
	On programme le "Synchronous Clock Controller" en entré CLK, en sortie 3 horloges par les 3 bus interes du Microprocesseur: APBA, APBB et APBC.\\
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.8\linewidth]{product mapping_SAMD21.jpg}
		\caption{Cartographie des produits Atmel SAM D21}
	\end{figure}
	D'après la cartographie des produits, le Timer TC6 est place sur le bus APBC. Donc il faut configurer les registres:
	\begin{itemize}
		\item {APBCSEL}
		\item {APBCMASK}
		\item {CPUSEL}
	\end{itemize}
	\paragraph{Configuration du registre APBCSEL} 
	~~\\
	Le registre APBA Clock Select (APBCSEL) ne contient qu'un seul champ:\\
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{APBCSEL.jpg}
		\caption{Configuration des différents bits du APBCSEL}
	\end{figure}
	
	\begin{itemize}
		\item {\bf APBCDIV[2:0]}: Définit le facteur de division de l'horloge d'entrée GCLKMAIN. On choisit la division par 1 donc il faut mettre {\bf 0\textless\textless0}.~~\\
	\end{itemize}
	
	\paragraph{Configuration du registre APBCMASK} 
	~~\\
	Le registre APBC Mask (APBCMASK) contient les validations d'horloge bus pour tous les périphériques connectes sur le bus APBC.
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{APBCMASK.jpg}
		\caption{Configuration des différents bits du APBCMASK}
	\end{figure}
	Les bits 20:0 permettent de stopper les différentes horloges bus de APBC s’ils sont mis à zéro ou bien de les activer s’ils sont mis à un.
	\begin{itemize}
		\item {\bf TC6}: Ici on veut activer l’horloge bus pour TC6 donc il faut mettre {\bf 1\textless\textless14}.~~\\
	\end{itemize}
	
	\paragraph{Configuration du registre CPUCSEL} 
	~~\\
	Le registre CPU Clock Select (CPUSEL) ne contient qu'un seul champ:
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{CPUSEL.jpg}
		\caption{Configuration des différents bits du CPUSEL}
	\end{figure}
	\begin{itemize}
		\item {\bf CPUDIV[2:0]}: Permet de définir de facteur de division de l'horloge du CPU par rapport à GCLKMAIN. On choisit la division par 1 donc il faut mettre {\bf 0\textless\textless0}.~~\\
	\end{itemize}
	
	\subsubsection{Configuration des ports d'E/S parallèles} 
	Le nombre de pattes du microprocesseur est limité: le SAMD21 possède 64 pattes, un nombre bien inférieur à la somme des entrées/sorties de tous les périphériques.\\
    Il faut donc multiplexer les entrées ou les sorties des périphériques via les ports d’entrée/sortie A et B.\\
    Dans un premier il nous faut donc trouver sur quelles pins, et dans quel multiplexage il est possible d’observer le signal WO[0] du TC6. D’après la table de multiplexage présente dans la datasheet du SAMD21, ce signal est disponible sur 2 pins : PB02 et PB16, en multiplexage {\bf E}. Cependant la pin PB16 est utilisé aussi pour d’autre fonction, il est donc préférable de prendre la PB02.\\
    Pour accéder a la sortie WO[0] de TC6, il faudra configurer :
    \begin{itemize}
		\item {Registre \bf DIRSET} pour choisir la broche PB02 en sortie
		\item {Registre \bf PMUX} pour choisir le multiplexage de type E
		\item {Registre \bf PINCFG} pour valider le multiplexage choisi
	\end{itemize}
	
	\paragraph{Configuration du registre DIRSET} 
	~~\\
	Le registre Data Direction Set (DIRSET) permet à l'utilisateur de définir une ou plusieurs broches d'E/S en sortie. \\
	Ce registre sert à mettre à 1 en bits correspondants dans le registre DIR. Le registre DIR contient le configuration de chacune des pattes du port A ou B. \\
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{DIRSET.jpg}
		\caption{Configuration des différents bits du CPUSEL}
	\end{figure}
	\begin{itemize}
		\item {\bf DIRSET[31:0]}: Le bit à 0 n'a aucun effet. Le bit à 1 configure la broche d'E/S comme une sortie. Pour le port B, il faut configurer la patte 2 en sortie donc il faut mettre {\bf 1\textless\textless2}.
	\end{itemize}
	
	\paragraph{Configuration du registre PMUX} 
	~~\\
	Il y a jusqu'à 16 registres de multiplexage périphérique dans chaque groupe, un pour chaque ensemble de deux lignes d'E/S. Le n désigne le numéro de l'ensemble des lignes d'E/S.\\
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{Registre du PMUXn.jpg}
		\caption{Registre du PMUXn}
	\end{figure}
	Le registre  Peripheral Multiplexing n (PMUXn) est composé de 16 octets, chacun composé de 2 parties : 4 bits pour les pins impaires, 4 bits pour les pins paires. Ainsi PMUX0 contient le multiplexage des pins 0 (paire) et 1 (impaire). La pin 2 est alors la partie paire de PMUX1.  
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{PMUX.jpg}
		\caption{Configuration des différents bits du PMUXn}
	\end{figure}
	
	\begin{itemize}
		\item {\bf PMUXE[3:0]}: 0×0 étant le multiplexage A, et 0×8 le I. On spécifie alors le multiplexage à mettre en place : E, donc il faut mettre la valeur {\bf 0×4\textless\textless0}.
	\end{itemize}
	
	\paragraph{Configuration du registre PINCFG} 
	~~\\
	Enfin, il faut activer la pin PB02 en passant par les registres Pin Configuration (PINCFG). Ces registres sont définis comme suit:   
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{PINCFGn.jpg}
		\caption{Configuration des différents bits du PINCFGn}
	\end{figure}
	
	\begin{itemize}
		\item {\bf DRVSTR}: Contrôle la force du driver de sortie. 1 pour fort, 0 pour normal. Ne nous concerne pas ici donc il faut mettre {\bf 0\textless\textless6} dans ce champ.~~\\
		\item {\bf PULLEN}: Active ou non un la résistance pull-up ou pull-down interne d'une broche d'E/S configurée en entrée. Ne nous concerne pas ici, donc {\bf 0\textless\textless2}.~~\\
		\item {\bf INEN}: : Validation de la patte comme une entrée. On considère ici une sortie donc il faut mettre {\bf 0\textless\textless1} dans ce champ.~~\\
		\item {\bf PMUXEN}: Validation ou non le multiplexage E mis en place par le registre PMUX correpondant donc il faut mettre {\bf 1\textless\textless0}.~~\\
	\end{itemize}
	
	\subsubsection{Configuration du périphérique} 
	Nous utiliserons pour cette partie le Timer Counter 6 (TC6) configuré dans le mode 16 bits.\\
	Pour générer un signal de fréquence 1kHz, il faut programmer le registre:
	\begin{itemize}
		\item {CTRLA}
		\item {CTRLBLR}
		\item {CTRLC}
		\item {CC0}
	\end{itemize}
	\paragraph{Configuration du registre CTRLA} 
	~~\\
	Le détail de Control A (CTRLA) est donné dans la figure ci-dessous :
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{ControlA.jpg}
		\caption{Configuration des différents bits du CTRLA}
	\end{figure}
	
	\begin{itemize}
		\item {\bf PRESCSYNC[1:0]}: Le registre de comptage est piloté par une horloge issue de GCLK\_TC via un prescaler. Il faut donc mettre la valeur {\bf 1\textless\textless12}.~~\\
		\item {\bf RUNSTDBY}: Définit le fonctionnement du TC en mode STANDBY. Il n’y a pas d’intérêt à garder le TC actif en veille donc {\bf 0\textless\textless11}.~~\\
		\item {\bf PRESCALER[2:0]}: Applique un facteur de division à l’horloge d’entrée entre 1 et 1024. Il ne sera pas nécessaire de diviser au préalable l’horloge donc on garde un prescaler de 1 alors {\bf 0\textless\textless8}.~~\\
		\item {\bf WAVEGEN[1:0]}: Sélectionne le mode de fonctionnement du compteur. Le mode MFRQ est utilisé, il faut donc {\bf 1\textless\textless5}.~~\\
		\item {\bf MODE[1:0]}: Sélectionne le mode de comptage pour le compteur, c’est-àdire le nombre de bits de comptage : 8, 16 ou 32 bits. Il nous faut ici compter 4000 valeurs (de 0 à 3999) d’après le modèle présenté en début de section. C’est donc le mode 16 bits qui est choisi, alors {\bf 0\textless\textless2}.~~\\
		\item {\bf ENABLE}: Valide le timer ou non. Ici nous voulons le valider donc il faut mettre la valeur {\bf 1\textless\textless1}.~~\\
		\item {\bf SWRST}: Nous ne voulons pas de RESET du Timer donc il faut mettre la valeur {\bf 0\textless\textless0}.~~\\
	\end{itemize}
	
	\paragraph{Configuration du registre CTRLBCLR} 
	~~\\
	Le détail de Control B Clear (CTRLBCLR) est donné dans la figure ci-dessous :
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{CTRLBCLR.jpg}
		\caption{Configuration des différents bits du CTRLBCLR}
	\end{figure}
	
	\begin{itemize}
		\item {\bf CMD[1:0]}: Sélectionne la commande lors du prochain cycle de GCLK du TC: NONE, RETRIGGER ou STOP. Aucun comportement particulier n’est souhaité, on place alors NONE {\bf 0\textless\textless6}.~~\\
		\item {\bf ONESHOT}: Le One-Shot stop le compteur lors d’un débordement du compteur (inférieur à 0 ou supérieur à la valeur maximale). Placé ce bit à 1 stop cette fonctionnalité. On veut le désactiver donc il faut mettre la valeur {\bf 1\textless\textless2}.~~\\
		\item {\bf DIR}: Paramètre le sens de comptage : incrémentation(1) ou décrémentation(0). On choisit le mode incrémention donc {\bf 1\textless\textless0}.~~\\
	\end{itemize}
	
	\paragraph{Configuration du registre CTRLC} 
	~~\\
	Le détail de Control C (CTRLC) est donné dans la figure ci-dessous :
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{CTRLC.jpg}
		\caption{Configuration des différents bits du CTRLC}
	\end{figure}
	
	\begin{itemize}
		\item {\bf CPTENx}: Autorise la capture sur les channel 1 et 0. On veut désactiver le mode capture 1 et capture 0 donc il faut mettre la valeur {\bf 0\textless\textless5} et {\bf 0\textless\textless4}.~~\\
		\item {\bf INVENx}: Inverse les sorties WO[1] et WO[0] lorsque ces bits sont à 1. On ne veut pas inverser la sortie WO[1] et WO[0] donc il faut mettre la valeur {\bf 0\textless\textless1} et {\bf 0\textless\textless0}.~~\\
	\end{itemize}
	
	\paragraph{Configuration du registre CC0} 
	~~\\
	Ce registre permet de définir la demi période CC0 du signal W0[0]. \\
	D’après les calculs présenté précédemment, pour générer un signal de fréquence 1kHz, la valeur chargée dans le registre CC0 sera 3999.\\
	
	\subsection{Test et validation}
	Maintenant que le programmes est terminé, il est implanté sur la carte.\\
	A l’aide d’un oscilloscope, on visualise le signal de sortie sur la pin PB02 paramétrée précédemment. Le signal en sortie du TC6 présenté en figure ci-dessous:
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{chrono_valide_etape2.jpg}
		\caption{Signal de sortie du TC6}
	\end{figure}
	On obtient bien un signal carré de fréquence 1kHz comme signal en sortie du TC6.

	
	\newpage
	
	
	\section{Fonction sous interruption}
	Les interruptions sont des outils essentiels pour concevoir des systèmes réactifs (en: responsive)  dès lors qu'ils doivent exécuter des opérations logicielles et matérielles simultanément. Avant de présenter le fonctionnement et la configuration du système d'interruption du Cortex-M il est préférable de donner un aperçu du problème. \\
	\subsection{Présentation du problème}
	L'environnement avec lequel interagi le microcontrôleur est dit asynchrone. Il ne peut à priori par connaître l'instant d'apparition d'un événement. Il est alors obligé de le scruter fréquemment pour être averti rapidement d'un changement. C'est précisément ce que fait l'étape 1. La lecture du bouton est placée dans une boucle infinie, si l'utilisateur appui sur ce denier l'état de la led est modifié. Bien que ce programme soit inefficace, il fonctionne bien et offre une faible latence. Ce mode de fonctionnement est appelé "polling". Le problème survient dès lors qu'une tâche logicielle est ajoutée au programme. Le processeur n'est plus seulement occupé à contrôler l'état du bouton mais également à exécuter une autre partie du programme. La réactivité n'est alors plus garantie. Dans certains cas, si la tâche logicielle est importante, le changement d'état du bouton pourra être invisible pour le programme.
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{polling_task}
		\caption{Ordonnancement tâches avec polling}
	\end{figure}
	La figure ci-dessus représente l'exécution d'un programme comme celui de l'étape 1 auquel une seconde tâche a été ajoutée (tâche 2). Aucune échelle précise n'est choisi le but étant une simple présentation fonctionnelle. Deux cas sont illustrés dans cet exemple. Le premier, à gauche, correspond au bon déroulement, le processeur lit de manière successive l'état du switch (étape 1), lorsque une lecture vaut '1' l'état de la led est mis à '1' et même chose pour '0'. Une petite (latence) est présente mais elle sera généralement négligée. Dans le second cas, à droite, la tâche 2 est en cours d'exécution est empêche la lecture du bouton. Une fois terminée la mise à jours de la led peut s'opérer comme précédement. L'exécution de la tâche 2 a générer un retard qui n'est cette fois-ci plus négligeable du point de vue de l'utilisateur. Si la tâche 2 avait durée un instant de plus ale système n'aurait pas réagi à la stimulation. Un tel cas ne doit, en aucun cas, se produire pour un système dont la sécurité est critique.\\
	En pratique ce problème survient fréquemment. Les interactions utilisateurs, tel que l'appuis sur un bouton, sont relativement lentes comparés à la vitesse de fonctionnement des processeurs. Un "polling" pourra suffire dans certains cas. Mais pour ce qui est des événements matériels, comme un timer ou un protocole série, la situation est plus critique. Il n'y a alors pas d'autres solutions que d'utiliser une interruption. De manière générale les logiciels utilisant des interruptions fonctionnent plus efficacement que ceux basés sur le "pooling". Aucun temps n'est perdu à contrôler l'apparition d'un événement. L'approche par déclenchement sur évènements (en: even-trigger) offre également une meilleur réactivité. Des ressources pourront alors être économisées en baissant la fréquence ne fonctionnement. \cite{ARM_book}
	\subsection{Fonctionnement d'une interruption }
	Une interruption est définie comme une suspension temporaire de l'exécution d'un programme informatique par le microprocesseur afin d'exécuter un programme prioritaire (routine d'interruption). La dite suspension est déclenchée par une source externe. \\
	La gestion d'une interruption s'effectue comme tel : pause du programme, sauvegarde du contexte, identification de la routine d'interruption à exécuter (en fonction de ma source), exécution de la routine et rétablissent du contexte. Ces actions sont gérées par le NVIC, Nest Vectored Interrupt Controler faisant l'interface entre les périphériques et le CPU.
	
	
	
	\bibliography{lib}{}
	\bibliographystyle{unsrt}
	
\end{document}

\begin{itemize}
	\renewcommand{\labelitemi}{--}
\end{itemize}